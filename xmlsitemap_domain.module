<?php

/**
 * @file
 * XML Sitemap Domain module file.
 *
 * Integrates XML Sitemap with Domain Access to provide per-domain sitemaps.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Url;

/**
 * Implements hook_form_alter().
 *
 * Adds domain management to XML Sitemap configuration.
 */
function xmlsitemap_domain_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Debug: Log xmlsitemap form IDs to help troubleshooting.
  if (strpos($form_id, 'xmlsitemap') !== FALSE) {
    \Drupal::logger('xmlsitemap_domain')->notice('Form ID: @form_id', ['@form_id' => $form_id]);
  }

  // Target the main XML Sitemap settings form.
  if ($form_id === 'xmlsitemap_settings_form') {
    _xmlsitemap_domain_add_domain_management($form, $form_state);
  }
}

/**
 * Adds domain management section to XML Sitemap settings.
 */
function _xmlsitemap_domain_add_domain_management(&$form, FormStateInterface $form_state) {
  // Check if domain module is available.
  if (!\Drupal::moduleHandler()->moduleExists('domain')) {
    \Drupal::messenger()->addWarning(t('Domain Access module is required for domain-specific sitemaps.'));
    return;
  }

  $domain_storage = \Drupal::entityTypeManager()->getStorage('domain');
  $domains = $domain_storage->loadMultiple();

  if (empty($domains)) {
    \Drupal::messenger()->addWarning(t('No domains found. Please configure domains first.'));
    return;
  }

  // Add domain-specific sitemap section.
  $form['xmlsitemap_domain'] = [
    '#type' => 'details',
    '#title' => t('Domain-Specific Sitemaps'),
    '#description' => t('Generate separate XML sitemaps for each domain. Each sitemap will only include content assigned to that domain.'),
    '#open' => TRUE,
    '#weight' => -5,
  ];

  // Get current domain configuration.
  $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

  $form['xmlsitemap_domain']['enabled_domains'] = [
    '#type' => 'checkboxes',
    '#title' => t('Enable sitemaps for domains'),
    '#description' => t('Select which domains should have their own sitemap. Each enabled domain will generate a sitemap at /sitemap-[domain_id].xml'),
    '#options' => [],
    '#default_value' => $enabled_domains,
  ];

  foreach ($domains as $domain_id => $domain) {
    $form['xmlsitemap_domain']['enabled_domains']['#options'][$domain_id] = t('@label (@hostname)', [
      '@label' => $domain->label(),
      '@hostname' => $domain->getHostname(),
    ]);
  }

  $form['xmlsitemap_domain']['info'] = [
    '#type' => 'markup',
    '#markup' => '<p>' . t('After enabling domains, sitemaps will be available at:') . '</p><ul>',
  ];

  $base_url = \Drupal::request()->getSchemeAndHttpHost();
  foreach ($domains as $domain_id => $domain) {
    $sitemap_url = $base_url . '/sitemap-' . $domain_id . '.xml';
    $form['xmlsitemap_domain']['info']['#markup'] .= '<li><strong>' . $domain->label() . ':</strong> <a href="' . $sitemap_url . '" target="_blank">' . $sitemap_url . '</a></li>';
  }
  $form['xmlsitemap_domain']['info']['#markup'] .= '</ul>';

  // Add custom submit handler.
  $form['#submit'][] = 'xmlsitemap_domain_settings_form_submit';
}

/**
 * Submit handler for XML Sitemap settings form.
 */
function xmlsitemap_domain_settings_form_submit($form, FormStateInterface $form_state) {
  $enabled_domains = array_filter($form_state->getValue('enabled_domains', []));
  \Drupal::state()->set('xmlsitemap_domain_enabled', $enabled_domains);

  \Drupal::messenger()->addStatus(t('Domain-specific sitemaps have been configured. Sitemaps will be regenerated.'));

  // Trigger regeneration for each enabled domain.
  foreach ($enabled_domains as $domain_id) {
    xmlsitemap_domain_regenerate_sitemap($domain_id);
  }
}

/**
 * Implements hook_entity_insert().
 */
function xmlsitemap_domain_entity_insert(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_update().
 */
function xmlsitemap_domain_entity_update(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_delete().
 */
function xmlsitemap_domain_entity_delete(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Helper function to regenerate sitemap on entity changes.
 */
function _xmlsitemap_domain_regenerate_on_entity_change(EntityInterface $entity) {
  // Only process content entities.
  if (!$entity->getEntityType()->get('field_ui_base_route')) {
    return;
  }

  // Check if auto-regenerate is enabled.
  if (!\Drupal::config('xmlsitemap_domain.settings')->get('auto_regenerate')) {
    return;
  }

  // Determine which domain(s) this content belongs to.
  $affected_domains = [];
  if ($entity->hasField('field_domain_access')) {
    $domain_values = $entity->get('field_domain_access')->getValue();
    $affected_domains = array_column($domain_values, 'target_id');
  }

  // Check enabled domains.
  $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

  // Regenerate sitemaps for affected domains.
  foreach ($affected_domains as $domain_id) {
    if (in_array($domain_id, $enabled_domains)) {
      xmlsitemap_domain_regenerate_sitemap($domain_id);
    }
  }
}

/**
 * Regenerates sitemap for a specific domain.
 */
function xmlsitemap_domain_regenerate_sitemap($domain_id) {
  // Set the current domain context for sitemap generation.
  \Drupal::state()->set('xmlsitemap_domain_current', $domain_id);

  // Queue the sitemap for regeneration.
  \Drupal::state()->set('xmlsitemap_regenerate_needed', TRUE);

  // Clear the context.
  \Drupal::state()->delete('xmlsitemap_domain_current');
}

/**
 * Implements hook_xmlsitemap_links_alter().
 */
function xmlsitemap_domain_xmlsitemap_links_alter(array &$links, $context, $entity_type_id) {
  $current_domain = \Drupal::state()->get('xmlsitemap_domain_current');

  if (!$current_domain) {
    return;
  }

  // Filter links based on domain access.
  foreach ($links as $key => $link) {
    // Try to load the entity.
    if (!empty($link['id'])) {
      list($entity_type, $entity_id) = explode(':', $link['id']);

      try {
        $entity_storage = \Drupal::entityTypeManager()->getStorage($entity_type);
        $entity = $entity_storage->load($entity_id);

        if ($entity && $entity->hasField('field_domain_access')) {
          $domain_values = $entity->get('field_domain_access')->getValue();
          $entity_domains = array_column($domain_values, 'target_id');

          // Check for "All affiliates" option.
          $all_affiliates = FALSE;
          if ($entity->hasField('field_domain_all_affiliates')) {
            $all_affiliates = $entity->get('field_domain_all_affiliates')->value;
          }

          // Exclude if not in this domain.
          if (!$all_affiliates && !empty($entity_domains) && !in_array($current_domain, $entity_domains)) {
            unset($links[$key]);
          }
        }
      }
      catch (\Exception $e) {
        // Skip if entity can't be loaded.
        continue;
      }
    }
  }
}

/**
 * Implements hook_page_attachments().
 */
function xmlsitemap_domain_page_attachments(array &$attachments) {
  // Check if we're on a domain.
  if (!\Drupal::moduleHandler()->moduleExists('domain')) {
    return;
  }

  $domain_negotiator = \Drupal::service('domain.negotiator');
  $active_domain = $domain_negotiator->getActiveDomain();

  if (!$active_domain) {
    return;
  }

  // Check if this domain has sitemap enabled.
  $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

  if (in_array($active_domain->id(), $enabled_domains)) {
    // Add link to domain-specific sitemap in HTML head.
    $attachments['#attached']['html_head'][] = [
      [
        '#tag' => 'link',
        '#attributes' => [
          'rel' => 'sitemap',
          'type' => 'application/xml',
          'title' => 'Sitemap',
          'href' => Url::fromRoute('xmlsitemap_domain.sitemap', ['domain_id' => $active_domain->id()])->toString(),
        ],
      ],
      'xmlsitemap_domain_' . $active_domain->id(),
    ];
  }
}
