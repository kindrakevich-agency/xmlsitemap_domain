<?php

/**
 * @file
 * XML Sitemap Domain module file.
 *
 * Integrates XML Sitemap with Domain Access to provide per-domain sitemaps.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;

/**
 * Implements hook_form_alter().
 */
function xmlsitemap_domain_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Target the main XML Sitemap settings form.
  if ($form_id === 'xmlsitemap_admin_settings') {
    _xmlsitemap_domain_add_domain_management($form, $form_state);
  }
}

/**
 * Adds domain management section to XML Sitemap settings.
 */
function _xmlsitemap_domain_add_domain_management(&$form, FormStateInterface $form_state) {
  // Check if domain module is available.
  if (!\Drupal::moduleHandler()->moduleExists('domain')) {
    \Drupal::messenger()->addWarning(t('Domain Access module is required for domain-specific sitemaps.'));
    return;
  }

  $domain_storage = \Drupal::entityTypeManager()->getStorage('domain');
  $domains = $domain_storage->loadMultiple();

  if (empty($domains)) {
    \Drupal::messenger()->addWarning(t('No domains found. Please configure domains first.'));
    return;
  }

  // Add domain-specific sitemap section.
  $form['xmlsitemap_domain'] = [
    '#type' => 'details',
    '#title' => t('Domain-Specific Sitemaps'),
    '#description' => t('Generate separate XML sitemaps for each domain. Each sitemap will only include content assigned to that domain.'),
    '#open' => TRUE,
    '#weight' => -5,
  ];

  // Get current domain configuration.
  $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

  $form['xmlsitemap_domain']['enabled_domains'] = [
    '#type' => 'checkboxes',
    '#title' => t('Enable sitemaps for domains'),
    '#description' => t('Select which domains should have their own sitemap. Each enabled domain will generate a sitemap at /sitemap.xml when accessed from that domain.'),
    '#options' => [],
    '#default_value' => $enabled_domains,
  ];

  foreach ($domains as $domain_id => $domain) {
    $form['xmlsitemap_domain']['enabled_domains']['#options'][$domain_id] = t('@label (@hostname)', [
      '@label' => $domain->label(),
      '@hostname' => $domain->getHostname(),
    ]);
  }

  $form['xmlsitemap_domain']['info'] = [
    '#type' => 'markup',
    '#markup' => '<p>' . t('After enabling domains, sitemaps will be available at:') . '</p><ul>',
  ];

  foreach ($domains as $domain_id => $domain) {
    // Build proper domain URL.
    $domain_url = $domain->getScheme() . $domain->getHostname();
    $sitemap_url = $domain_url . '/sitemap.xml';
    $form['xmlsitemap_domain']['info']['#markup'] .= '<li><strong>' . $domain->label() . ':</strong> <a href="' . $sitemap_url . '" target="_blank">' . $sitemap_url . '</a></li>';
  }
  $form['xmlsitemap_domain']['info']['#markup'] .= '</ul>';

  // Add custom submit handler.
  $form['#submit'][] = 'xmlsitemap_domain_settings_form_submit';
}

/**
 * Submit handler for XML Sitemap settings form.
 */
function xmlsitemap_domain_settings_form_submit($form, FormStateInterface $form_state) {
  $enabled_domains = array_filter($form_state->getValue('enabled_domains', []));
  \Drupal::state()->set('xmlsitemap_domain_enabled', $enabled_domains);

  // Create separate sitemap contexts for each enabled domain.
  foreach ($enabled_domains as $domain_id) {
    $context = ['domain' => $domain_id];
    xmlsitemap_sitemap_save(['context' => $context]);
  }

  \Drupal::messenger()->addStatus(t('Domain-specific sitemaps have been configured.'));
}

/**
 * Implements hook_entity_insert().
 */
function xmlsitemap_domain_entity_insert(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_update().
 */
function xmlsitemap_domain_entity_update(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_delete().
 */
function xmlsitemap_domain_entity_delete(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Helper function to regenerate sitemap on entity changes.
 */
function _xmlsitemap_domain_regenerate_on_entity_change(EntityInterface $entity) {
  // Only process content entities.
  if (!$entity->getEntityType()->get('field_ui_base_route')) {
    return;
  }

  // Check if auto-regenerate is enabled.
  if (!\Drupal::config('xmlsitemap_domain.settings')->get('auto_regenerate')) {
    return;
  }

  // Determine which domain(s) this content belongs to.
  $affected_domains = [];
  if ($entity->hasField('field_domain_access')) {
    $domain_values = $entity->get('field_domain_access')->getValue();
    $affected_domains = array_column($domain_values, 'target_id');
  }

  // Check enabled domains.
  $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

  // Regenerate sitemaps for affected domains.
  foreach ($affected_domains as $domain_id) {
    if (in_array($domain_id, $enabled_domains)) {
      $context = ['domain' => $domain_id];
      $sitemap = xmlsitemap_sitemap_load_by_context($context);
      if ($sitemap) {
        xmlsitemap_sitemap_save($sitemap);
      }
    }
  }
}

/**
 * Implements hook_xmlsitemap_sitemap_context().
 *
 * Sets the context based on the active domain.
 */
function xmlsitemap_domain_xmlsitemap_sitemap_context() {
  \Drupal::logger('xmlsitemap_domain')->notice('hook_xmlsitemap_sitemap_context() called');

  $contexts = [];

  // Check if domain module is available.
  if (!\Drupal::moduleHandler()->moduleExists('domain')) {
    \Drupal::logger('xmlsitemap_domain')->warning('Domain module not available');
    return $contexts;
  }

  // Get the active domain.
  $domain_negotiator = \Drupal::service('domain.negotiator');
  $active_domain = $domain_negotiator->getActiveDomain();

  \Drupal::logger('xmlsitemap_domain')->notice('Active domain: @domain', [
    '@domain' => $active_domain ? $active_domain->id() : 'none',
  ]);

  if ($active_domain) {
    $current_domain_id = $active_domain->id();

    // Check if this domain has sitemap enabled.
    $enabled_domains = \Drupal::state()->get('xmlsitemap_domain_enabled', []);

    \Drupal::logger('xmlsitemap_domain')->notice('Enabled domains: @domains', [
      '@domains' => implode(', ', $enabled_domains),
    ]);

    if (in_array($current_domain_id, $enabled_domains)) {
      $contexts[] = ['domain' => $current_domain_id];
      \Drupal::logger('xmlsitemap_domain')->notice('Returning context for domain: @domain', [
        '@domain' => $current_domain_id,
      ]);
    } else {
      \Drupal::logger('xmlsitemap_domain')->warning('Domain @domain not in enabled list', [
        '@domain' => $current_domain_id,
      ]);
    }
  }

  return $contexts;
}

/**
 * Implements hook_xmlsitemap_links_alter().
 */
function xmlsitemap_domain_xmlsitemap_links_alter(array &$links, $context, $entity_type_id) {
  // Only filter if we have a domain context.
  if (empty($context['domain'])) {
    return;
  }

  $current_domain_id = $context['domain'];

  \Drupal::logger('xmlsitemap_domain')->notice('Filtering links for domain context: @domain (total links: @count)', [
    '@domain' => $current_domain_id,
    '@count' => count($links),
  ]);

  $removed_count = 0;
  $kept_count = 0;

  // Filter links based on domain access.
  foreach ($links as $key => $link) {
    // Try to load the entity.
    if (!empty($link['id'])) {
      $parts = explode(':', $link['id']);
      if (count($parts) >= 2) {
        list($entity_type, $entity_id) = $parts;

        try {
          $entity_storage = \Drupal::entityTypeManager()->getStorage($entity_type);
          $entity = $entity_storage->load($entity_id);

          if ($entity && $entity->hasField('field_domain_access')) {
            $domain_values = $entity->get('field_domain_access')->getValue();
            $entity_domains = array_column($domain_values, 'target_id');

            // Check for "All affiliates" option.
            $all_affiliates = FALSE;
            if ($entity->hasField('field_domain_all_affiliates')) {
              $all_affiliates = $entity->get('field_domain_all_affiliates')->value;
            }

            // Exclude if not in this domain.
            if (!$all_affiliates && !empty($entity_domains) && !in_array($current_domain_id, $entity_domains)) {
              unset($links[$key]);
              $removed_count++;
            } else {
              $kept_count++;
            }
          }
        }
        catch (\Exception $e) {
          // Skip if entity can't be loaded.
          continue;
        }
      }
    }
  }

  \Drupal::logger('xmlsitemap_domain')->notice('Domain filtering complete: kept @kept, removed @removed', [
    '@kept' => $kept_count,
    '@removed' => $removed_count,
  ]);
}

/**
 * Implements hook_xmlsitemap_element_alter().
 *
 * Rewrites URLs to use the domain's base URL from context.
 */
function xmlsitemap_domain_xmlsitemap_element_alter(array &$element, array $link, $sitemap) {
  // Only rewrite if we have a domain context.
  $context = $sitemap->getContext();
  if (empty($context['domain'])) {
    return;
  }

  $domain_id = $context['domain'];

  // Load the domain.
  try {
    $domain_storage = \Drupal::entityTypeManager()->getStorage('domain');
    $domain = $domain_storage->load($domain_id);

    if ($domain && !empty($element['loc'])) {
      $current_url = $element['loc'];

      // Parse the current URL and replace the domain.
      $parsed = parse_url($current_url);

      if ($parsed) {
        $domain_url = $domain->getScheme() . $domain->getHostname();
        $path = $parsed['path'] ?? '/';
        $query = !empty($parsed['query']) ? '?' . $parsed['query'] : '';
        $fragment = !empty($parsed['fragment']) ? '#' . $parsed['fragment'] : '';

        $element['loc'] = $domain_url . $path . $query . $fragment;
      }
    }
  }
  catch (\Exception $e) {
    // Skip if domain can't be loaded.
  }
}
