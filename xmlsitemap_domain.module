<?php

/**
 * @file
 * XML Sitemap Domain module file.
 *
 * Integrates XML Sitemap with Domain Access to provide per-domain sitemaps.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;

/**
 * Implements hook_form_FORM_ID_alter() for xmlsitemap_sitemap_form.
 *
 * Adds domain selection field to sitemap add/edit forms.
 */
function xmlsitemap_domain_form_xmlsitemap_sitemap_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Check if domain module is available.
  if (!\Drupal::moduleHandler()->moduleExists('domain')) {
    return;
  }

  $domain_storage = \Drupal::entityTypeManager()->getStorage('domain');
  $domains = $domain_storage->loadMultiple();

  $options = [];
  foreach ($domains as $domain) {
    $options[$domain->id()] = $domain->label();
  }

  // Get current sitemap context.
  $sitemap = $form_state->getBuildInfo()['callback_object']->getEntity();
  $context = $sitemap->getContext();

  // Load existing domain association.
  $default_value = '';
  if (!empty($context)) {
    $domain_mapping = \Drupal::state()->get('xmlsitemap_domain_mapping', []);
    $context_key = is_array($context) ? serialize($context) : $context;
    $default_value = $domain_mapping[$context_key] ?? '';
  }

  $form['domain_id'] = [
    '#type' => 'select',
    '#title' => t('Domain'),
    '#description' => t('Select the domain for this sitemap. Only content from this domain will be included.'),
    '#options' => ['' => t('- Select a domain -')] + $options,
    '#default_value' => $default_value,
    '#required' => FALSE,
    '#weight' => -10,
  ];

  // Add custom submit handler.
  $form['actions']['submit']['#submit'][] = 'xmlsitemap_domain_sitemap_form_submit';
}

/**
 * Custom submit handler to save domain information with sitemaps.
 */
function xmlsitemap_domain_sitemap_form_submit($form, FormStateInterface $form_state) {
  $domain_id = $form_state->getValue('domain_id');
  $sitemap = $form_state->getBuildInfo()['callback_object']->getEntity();
  $context = $sitemap->getContext();

  if (!empty($context)) {
    $context_key = is_array($context) ? serialize($context) : $context;
    $domain_mapping = \Drupal::state()->get('xmlsitemap_domain_mapping', []);

    if ($domain_id) {
      $domain_mapping[$context_key] = $domain_id;
      \Drupal::messenger()->addStatus(t('Sitemap has been associated with the selected domain.'));
    } else {
      unset($domain_mapping[$context_key]);
    }

    \Drupal::state()->set('xmlsitemap_domain_mapping', $domain_mapping);

    // Trigger sitemap regeneration.
    if ($domain_id && \Drupal::config('xmlsitemap_domain.settings')->get('auto_regenerate')) {
      xmlsitemap_sitemap_save($sitemap->id());
      \Drupal::messenger()->addStatus(t('Sitemap has been queued for regeneration.'));
    }
  }
}

/**
 * Implements hook_entity_insert().
 *
 * Regenerates sitemap when new content is added.
 */
function xmlsitemap_domain_entity_insert(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_update().
 *
 * Regenerates sitemap when content is updated.
 */
function xmlsitemap_domain_entity_update(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Implements hook_entity_delete().
 *
 * Regenerates sitemap when content is deleted.
 */
function xmlsitemap_domain_entity_delete(EntityInterface $entity) {
  _xmlsitemap_domain_regenerate_on_entity_change($entity);
}

/**
 * Helper function to regenerate sitemap on entity changes.
 */
function _xmlsitemap_domain_regenerate_on_entity_change(EntityInterface $entity) {
  // Only process content entities.
  if (!$entity->getEntityType()->get('field_ui_base_route')) {
    return;
  }

  // Check if this entity type is included in sitemap.
  $entity_type = $entity->getEntityTypeId();
  $bundle = $entity->bundle();

  $settings = \Drupal::config("xmlsitemap.settings.$entity_type.$bundle");
  if (!$settings || !$settings->get('status')) {
    return;
  }

  // Check if auto-regenerate is enabled.
  if (!\Drupal::config('xmlsitemap_domain.settings')->get('auto_regenerate')) {
    return;
  }

  // Determine which domain(s) this content belongs to.
  $affected_domains = [];
  if ($entity->hasField('field_domain_access')) {
    $domain_values = $entity->get('field_domain_access')->getValue();
    $affected_domains = array_column($domain_values, 'target_id');
  }

  // Regenerate sitemaps for affected domains.
  if (!empty($affected_domains)) {
    $domain_mapping = \Drupal::state()->get('xmlsitemap_domain_mapping', []);

    foreach ($domain_mapping as $context_key => $domain_id) {
      if (in_array($domain_id, $affected_domains)) {
        // Queue this sitemap for regeneration.
        \Drupal::state()->set('xmlsitemap_regenerate_needed', TRUE);

        // Load and regenerate the sitemap.
        $context = @unserialize($context_key) ?: $context_key;
        if ($sitemap = xmlsitemap_sitemap_load_by_context($context)) {
          xmlsitemap_sitemap_save($sitemap);
        }
      }
    }
  }
}

/**
 * Implements hook_xmlsitemap_link_alter().
 *
 * Filters sitemap links based on the sitemap's domain.
 */
function xmlsitemap_domain_xmlsitemap_link_alter(&$link, EntityInterface $entity) {
  // Get the current sitemap context.
  $current_context = xmlsitemap_get_current_context();

  if (empty($current_context)) {
    return;
  }

  // Get domain mapping.
  $domain_mapping = \Drupal::state()->get('xmlsitemap_domain_mapping', []);
  $context_key = is_array($current_context) ? serialize($current_context) : $current_context;

  if (!isset($domain_mapping[$context_key])) {
    return;
  }

  $sitemap_domain = $domain_mapping[$context_key];

  // Check if entity has domain access field.
  if ($entity->hasField('field_domain_access')) {
    $domain_values = $entity->get('field_domain_access')->getValue();
    $entity_domains = array_column($domain_values, 'target_id');

    // Check for "All affiliates" option.
    $all_affiliates = FALSE;
    if ($entity->hasField('field_domain_all_affiliates')) {
      $all_affiliates = $entity->get('field_domain_all_affiliates')->value;
    }

    // Exclude link if not associated with current sitemap's domain.
    if (!$all_affiliates && !empty($entity_domains) && !in_array($sitemap_domain, $entity_domains)) {
      $link['access'] = FALSE;
      $link['status'] = FALSE;
    }
  }
}

/**
 * Implements hook_xmlsitemap_context_alter().
 *
 * Alters the sitemap context to include domain information.
 */
function xmlsitemap_domain_xmlsitemap_context_alter(&$context) {
  // Get domain mapping.
  $domain_mapping = \Drupal::state()->get('xmlsitemap_domain_mapping', []);
  $context_key = is_array($context) ? serialize($context) : $context;

  if (isset($domain_mapping[$context_key])) {
    $context['domain'] = $domain_mapping[$context_key];
  }
}

/**
 * Implements hook_xmlsitemap_context_url_options_alter().
 *
 * Alters URL options for domain-specific sitemaps.
 */
function xmlsitemap_domain_xmlsitemap_context_url_options_alter(&$options, $context) {
  if (!empty($context['domain'])) {
    $domain_storage = \Drupal::entityTypeManager()->getStorage('domain');
    $domain = $domain_storage->load($context['domain']);

    if ($domain) {
      // Set the base URL for this domain.
      $options['base_url'] = $domain->getScheme() . $domain->getHostname();
      $options['absolute'] = TRUE;
    }
  }
}
